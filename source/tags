!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
DISPLAY_ARRIVAL_TIME_CONST	dat-front.il	/^(defvar DISPLAY_ARRIVAL_TIME_CONST)$/;"	f
DISPLAY_ARRIVAL_TIME_OPTIONS_FORM	dat-front.il	/^(defvar DISPLAY_ARRIVAL_TIME_OPTIONS_FORM)$/;"	f
LOGIC_EXTRACTION_OPTIONS_FORM	c2v.il	/^(defvar LOGIC_EXTRACTION_OPTIONS_FORM)$/;"	f
andList	dat-back.il	/^(defun andList (xs)$/;"	f
assignAllCellInputLogics	c2v.il	/^(defun assignAllCellInputLogics (scv)$/;"	f
assqList	overlapBiasCurrent.il	/^(defun assqList (ls value)$/;"	f
c2v	c2v.il	/^(defun c2v (scv @key (flagArvTime "max"))$/;"	f
c2vFront	c2v.il	/^(defun c2vFront ()$/;"	f
calcArvTimeAll	dat-back.il	/^(defun calcArvTimeAll$/;"	f
calcArvTimeDiff	dat-back.il	/^(defun calcArvTimeDiff (arvTime inputTerm outputTerm)$/;"	f
calcArvTimeOutputTerm	dat-back.il	/^(defun calcArvTimeOutputTerm (inputTerm netDelayCoeff)$/;"	f
calcMinCP	dat-sta.il	/^(defun calcMinCP (orderITs propArvTime1 propArvTime2)$/;"	f
calcSlack	dat-sta.il	/^(defun calcSlack (it next propArvTime1 propArvTime2)$/;"	f
checkCalculability	dat-back.il	/^(defun checkCalculability (outputTerm)$/;"	f
combination	overlapBiasCurrent.il	/^(defun combination (n list)$/;"	f
compareArrivalTime	overlapBiasCurrent.il	/^(defun compareArrivalTime (inst1 inst2)$/;"	f
createOptionsForm	dat-front.il	/^(defun createOptionsForm (scv)$/;"	f
createOptionsForm2	c2v.il	/^(defun createOptionsForm2 (scv)$/;"	f
datGui	dat-front.il	/^(defun datGui ()$/;"	f
deleteAllArvTime	dat-back.il	/^(defun deleteAllArvTime (scv)$/;"	f
deleteInputLogics	c2v.il	/^(defun deleteInputLogics (scv)$/;"	f
diffCoord	overlapBiasCurrent.il	/^(defun diffCoord (coord1 coord2)$/;"	f
displayArrivalTime	dat-front.il	/^(defun displayArrivalTime (scv @key (paramList nil))$/;"	f
exchangeClkOut	dat-back.il	/^(defun exchangeClkOut (string)$/;"	f
exchangeDinDout	dat-back.il	/^(defun exchangeDinDout (string)$/;"	f
getCellTimingDependency	dat-back.il	/^(defun getCellTimingDependency (master)$/;"	f
getDelay	dat-back.il	/^(defun getDelay$/;"	f
getGridCoordBiasLeads	overlapBiasCurrent.il	/^(defun getGridCoordBiasLeads (instance)$/;"	f
getGridCoordInstLL	overlapBiasCurrent.il	/^(defun getGridCoordInstLL (instance)$/;"	f
getInstTermCoord	dat-front.il	/^(defun getInstTermCoord (instTerm)$/;"	f
getInterval	dat-sta.il	/^(defun getInterval$/;"	f
getOverlapBiasLeads	overlapBiasCurrent.il	/^(defun getOverlapBiasLeads ()$/;"	f
getParamsFromOptionsForm	dat-front.il	/^(defun getParamsFromOptionsForm ()$/;"	f
getParamsFromOptionsForm2	c2v.il	/^(defun getParamsFromOptionsForm2 ()$/;"	f
glueLabelsToInst	dat-front.il	/^(defun glueLabelsToInst (scv)$/;"	f
glueLabelsToInstTerm	dat-front.il	/^(defun glueLabelsToInstTerm (instTerm arvTime position)$/;"	f
haveMaxTimingConstraint	dat-back.il	/^(defun haveMaxTimingConstraint (inst)$/;"	f
inputTerms	dat-back.il	/^(defun inputTerms (inst) (setof x inst~>instTerms (isInputTerm x)))$/;"	f
inputTermsConnected	dat-back.il	/^(defun inputTermsConnected (pinOrOutputTerm)$/;"	f
inputTermsDependLogic	c2v.il	/^(defun inputTermsDependLogic (outputTerm)$/;"	f
inputTermsDependTiming	dat-back.il	/^(defun inputTermsDependTiming (outputTerm)$/;"	f
isCB	dat-back.il	/^(defun isCB (inst)$/;"	f
isCBJTLX	dat-back.il	/^(defun isCBJTLX (inst) (rexMatchp "^cb.jtl" inst~>cellName))$/;"	f
isCalculated	dat-back.il	/^(defun isCalculated (instTerm)$/;"	f
isClocked	dat-back.il	/^(defun isClocked (inst) (setof x inst~>instTerms x~>name == "clk"))$/;"	f
isD2ff	dat-back.il	/^(defun isD2ff (inst) (rexMatchp "^d2ff" inst~>cellName))$/;"	f
isDff	dat-back.il	/^(defun isDff (inst)$/;"	f
isDffe	dat-back.il	/^(defun isDffe (inst) (rexMatchp "^dffe" inst~>cellName))$/;"	f
isInputTerm	dat-back.il	/^(defun isInputTerm (instTerm) instTerm~>direction == "input")$/;"	f
isIpin	dat-back.il	/^(defun isIpin (inst) inst~>cellName == "ipin")$/;"	f
isJTL	dat-back.il	/^(defun isJTL (inst)$/;"	f
isJand	dat-back.il	/^(defun isJand (inst)$/;"	f
isJande	dat-back.il	/^(defun isJande (inst) (rexMatchp "^jande" inst~>cellName))$/;"	f
isJandf	dat-back.il	/^(defun isJandf (inst) (rexMatchp "^jandf" inst~>cellName))$/;"	f
isJnot	dat-back.il	/^(defun isJnot (inst)$/;"	f
isJnote	dat-back.il	/^(defun isJnote (inst) (rexMatchp "^jnote" inst~>cellName))$/;"	f
isJor	dat-back.il	/^(defun isJor (inst) (rexMatchp "^jor" inst~>cellName))$/;"	f
isJxor	dat-back.il	/^(defun isJxor (inst)$/;"	f
isJxore	dat-back.il	/^(defun isJxore (inst) (rexMatchp "^jxore" inst~>cellName))$/;"	f
isKand	dat-back.il	/^(defun isKand (inst)$/;"	f
isKnimply	dat-back.il	/^(defun isKnimply (inst)$/;"	f
isNdro	dat-back.il	/^(defun isNdro (inst)$/;"	f
isNdroc	dat-back.il	/^(defun isNdroc (inst) (rexMatchp "^ndroc" inst~>cellName))$/;"	f
isOpin	dat-back.il	/^(defun isOpin (inst) inst~>cellName == "opin")$/;"	f
isOutputTerm	dat-back.il	/^(defun isOutputTerm (instTerm) instTerm~>direction == "output")$/;"	f
isPTL	dat-back.il	/^(defun isPTL (inst)$/;"	f
isPTLDrv	dat-back.il	/^(defun isPTLDrv (inst) $/;"	f
isPTLDrvRec	dat-back.il	/^(defun isPTLDrvRec (inst) $/;"	f
isPTLFamily	dat-back.il	/^(defun isPTLFamily (inst) $/;"	f
isPTLRec	dat-back.il	/^(defun isPTLRec (inst) $/;"	f
isPspl	dat-back.il	/^(defun isPspl (inst) $/;"	f
isRdff	dat-back.il	/^(defun isRdff (inst)$/;"	f
isRjxor	dat-back.il	/^(defun isRjxor (inst) (rexMatchp "^rjxor" inst~>cellName))$/;"	f
isRoutingCell	dat-back.il	/^(defun isRoutingCell (inst) $/;"	f
isRtff	dat-back.il	/^(defun isRtff (inst) (rexMatchp "^rtff" inst~>cellName))$/;"	f
isSPL3JTLX	dat-back.il	/^(defun isSPL3JTLX (inst) (rexMatchp "^spl3.jtl" inst~>cellName))$/;"	f
isSPLJTLX	dat-back.il	/^(defun isSPLJTLX (inst) $/;"	f
isSource	dat-back.il	/^(defun isSource (inst) (rexMatchp "^source" inst~>cellName))$/;"	f
isT1	dat-back.il	/^(defun isT1 (inst) (rexMatchp "^t1" inst~>cellName))$/;"	f
isTff	dat-back.il	/^(defun isTff (inst) (rexMatchp "^tff" inst~>cellName))$/;"	f
logicCellType	c2v.il	/^(defun logicCellType (inst)$/;"	f
makeDelayTable	dat-back.il	/^(defun makeDelayTable (scv)$/;"	f
makeTimingDependencyTable	dat-back.il	/^(defun makeTimingDependencyTable (scv)$/;"	f
masterOutputTerminals	dat-back.il	/^(defun masterOutputTerminals (master)$/;"	f
maxList	dat-back.il	/^(defun maxList (xs)$/;"	f
minList	dat-back.il	/^(defun minList (xs)$/;"	f
netDistance	dat-back.il	/^(defun netDistance (net)$/;"	f
numStates	c2v.il	/^(defun numStates (inst)$/;"	f
orList	dat-back.il	/^(defun orList (xs)$/;"	f
orderInputs	c2v.il	/^(defun orderInputs (inst flagArvTime)$/;"	f
outputTerms	dat-back.il	/^(defun outputTerms (inst) (setof x inst~>instTerms (isOutputTerm x)))$/;"	f
outputTermsConnected	dat-back.il	/^(defun outputTermsConnected (pinOrInputTerm)$/;"	f
outputTermsDependTiming	dat-back.il	/^(defun outputTermsDependTiming (inputTerm)$/;"	f
pinsConnected	dat-back.il	/^(defun pinsConnected (instTerm) (car instTerm~>net~>pins~>figs))$/;"	f
plusCoord	overlapBiasCurrent.il	/^(defun plusCoord (coord1 coord2)$/;"	f
ptlType	dat-back.il	/^(defun ptlType (inst)$/;"	f
readVFile	dat-back.il	/^(defun readVFile (master)$/;"	f
removeAllLabels	dat-front.il	/^(defun removeAllLabels (scv)$/;"	f
rotateGridCoord	overlapBiasCurrent.il	/^(defun rotateGridCoord (listGCS)$/;"	f
setArvTime	dat-back.il	/^(defun setArvTime (outputTerm netDelayCoeff)$/;"	f
sideflipGridCoord	overlapBiasCurrent.il	/^(defun sideflipGridCoord (listGCS)$/;"	f
staticTimingAnalysis	dat-sta.il	/^(defun staticTimingAnalysis (scv flagArvTime flagFiltering)$/;"	f
transformGridCoord	overlapBiasCurrent.il	/^(defun transformGridCoord (gridCoord size rotate)$/;"	f
upperCenter	dat-front.il	/^(defun upperCenter (bBox)$/;"	f
